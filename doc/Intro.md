PrimalSpecでの形式仕様記述駆動開発
===================================

この文書について
-----------------

* 某所用の資料です
* 読者はCが書ける人を想定しています
* 目標はコレを読んだ人が
    * PrimaslSpecで書かれた記述が理解出来ること
    * PrimaslSpecでソフトウェアの仕様を記述すべきかどうか議論出来るようになること
* 前半はぽえむ


仕様の定義について
-------------------

* SW業界では、XX要求、要件、XX仕様、XX設計、実装という言葉をよく耳にしますが、それらの具体的な定義は組織や人によって様々です。
* ただ、規格や知識体系は存在していて、個人的に洗練されてると感じているのは[SWEBOK](http://swebokwiki.org/)です。
    * 第一、ニ章を読むだけで、要求、機能要求、非機能要求、仕様(SRS)、設計、verification & validation 等についての定義や雰囲気が分かるかと思います。
* とかいいつつも、ここではシンプルにシステム利用者から観測される振る舞いを仕様と呼ぶことにします。


なぜ、設計・実装前に仕様を書くのか？
--------------------------------------

まず、私が強調したい点は以下の１点です。

* 仕様や要求という抽象度が高いレイヤーであっても、いざ書いてみると様々な気づきが得られる
    * おや？思ったよりも難しそうだゾ
    * 具体的にどんなもの作ればいいんだっけ？どうやって検証するんだっけ？
    * 仕様レベルの間違いに気付ける(欠陥の中でこういった間違いの割合が多いことや、それらが手戻りになって開発工数伸びる話は書籍等でよく見かけます)

似たような効果があるものとしてプロトタイピングもありますが、こちらは機能の一部だけを動作するモノを実際に作ってみて顧客からのフィードバックを求めたり、技術的な仮説を検証したりするのが主な目的です。

一方、Karl E. Wiegers の"ソフトウェア要求"という本の第一章では何故設計・開発前に仕様を書くのかについて分かりやすく解説しています。
私見になりますが、その中でも以下の３つがビジネス面において最も重要なメリットと言えるかと思います。

1. 開発工数の増大防止
2. 見積り精度の向上
3. 顧客満足度の向上

また、仕様変更時においても、抽象度が高い分ソースコードを読むよりお手軽に修正範囲についてチェック出来ます。
もちろん結局はコードも見る必要はありますが、コードだけだと抽象度が低くボリュームが大きくなり見落としが怖いと筆者は感じてしまいます・・・


自然言語での記述のデメリット
-------------------------

思いつく範囲で挙げてみます。

* 複数人で記述する場合、口調や名前の統一やらが大変(チェックも大変)
* あるモノに対して皆が好き勝手名前をつけ始めると検索すらまともに出来なくなる
* 意味が一つに定まらない場合がある
* 行間を読まないといけない場合がある
* 記述した内容の整合性のチェックも難しい(結局は形式的にモデル作ることに・・・)
* 抽象化し辛くて、ボイラープレートが多くなる傾向がある
* なんとなく書けて、なんとなく読めて、なんとなく理解した気になってしまう
* 文法以外は機械チェックがし辛い


形式的な記述
-------------------------

形式的にモデルを記述する為のツールや言語は色々あって、それぞれ向き不向きがあったりするようです。

最もシンプルで馴染み深いものの１つは状態遷移モデルでしょう。
ここでいう状態遷移モデルの記述とは、状態遷移図もしくは状態集合、入力集合、出力集合、遷移関数、出力関数の組を書き下すことを指します。

しかし、状態遷移モデルは規模が大きくなると、記述がそもそも大変だったり読み辛かったりします。
この問題を解決する１つの手段としてCSPがあります。これは並行プロセスを記述する為に作られたものですが、並行性や非決定性についての演算を抜いても十分使える優れものです。

PrimalSpecはCSPから私のような原始人にはとても使いこなせない並行性と非決定性についての高度な演算子を取り除いたものになっています。(他にも✓ がないといった差異もあります)


PrimalSpecでの記述方法
-------------------------------

では、PrimalSpecでどのように仕様を記述するのかについて説明します。

### イベント

まずはイベントです。PrimalSpecでは主にイベントを使って仕様を記述します。ここでは、イベントとは状態遷移のトリガ、くらいの認識で良いです。

* 基本的に仕様を記述する場合、イベントとはシステム利用者とシステムを構成するマシンの間で共有される現象をモデル化したモノになります。
    * 具体的にはセンサ、通信ポート、ディスプレイ、モーター等についての振る舞いです。
* イベントはアトミックに発生します。つまり、あるイベントが発生している間に異なるイベントが発生するといった記述は出来ません。
* イベントにはペイロードをのせることが出来ます。
    * 例えば、```Fill 3``` で自動販売機にジュースを３本補充するというイベントを表すことが出来ます


### プロセス式

PrimalSpecでは、プロセス式とはイベントがどういう順番で発生しうるかを表現している式だと思って下さい。

プロセス式はイベント、原始プロセス、合成演算子によって構築されます。

* 原始プロセス
    * ```Stop``` : いかなるイベントが発生しても遷移は起こらないプロセス式。異常終了やデッドロックを表すのに使う
    * ```Skip``` : いかなるイベントが発生しても遷移は起こらないプロセス式。正常終了を表すのに使う。逐次合成時の振る舞いがStopとは異なる。
* 合成演算子
    * ```ev --> P``` : プリフィクス演算子
    * ```ev ?-> \x -> P``` : 受信演算子
    * ```P1 |=| P2``` : 外部選択演算子
    * 他にもガード、割り込み、逐次合成、アルファベット並行合成がありますが、省略

プロセス式はHaskellのeDSLで記述されます。プロセス変数というものは存在しません。Haskellの関数を使って抽象化します。


### 遷移と規則の記述方法

プロセス式P が イベントaを受理した後プロセスQとして振る舞うという命題は以下のように表現します。


       a
    P ===> Q


各命題に対して仮説部（線の上側）が全て成立すると結論部(線の下側)の各命題がそれぞれ成立すると読んでください。以下の場合、(P かつ Q) ならば (R かつ S) です。(R または S) ではない点に注意して下さい。


        P
        Q
    ----------
        R
        S


### Prefix演算子

```a --> P``` は イベントa を受け取ったらプロセスPとして振る舞うプロセスを意味します。


    ------------------
                a
     (a --> P) ===>  P


式の外で指定されたイベントのペイロードを使いたい場合は、受信演算子を使います。つまり、P の中でxはペイロードの中身を指します。


    -----------------------------
                        a y
     (a --> \x -> P(x)) ===>  P(y)


### 外部選択演算子

```P |=| Q``` は P またはQとして振る舞います。P,Q のどちらのイベントが先に起こった方が選択されます。


       a
    P ===> P'

       b
    Q ===> Q'

    --------------------
               a
    (P |=| Q) ===>  P'

               b
    (P |=| Q) ===>  Q'


PrimeSpecでは、b=aだった場合は非決定性遷移にせず、実行時エラーを出すようにしています。


### Haskell

HaskellについてはIntroductionforCProgrammer.md を参照


### 陰関数

入力と出力の関係を記述することで関数を陰形式で定義出来ます。
ただし、動作させる場合は自分で答えをコンソール等から入力しなければなりません。
答えが間違っていたらエラーになります。


### プロセス固有の状態管理

状態はHaskellの関数の引数という形で管理出来ます。


記述例
-----------

では、実際に PrimalSpecで自動販売機の仕様を記述していみましょう。

demo/Main.hs


おわりに
-----------

では、以下について議論しましょう

1. 設計・開発前に仕様は書くべきか？
    * Yes の場合 -> 仕様は何を使って書くべきか？
    * No の場合 -> 1 に戻る

